---
layout: post
title:  "leetcode reverse bits"
date:   2019-03-06 11:06:00 +0900
categories: java
---

# leetcode reverse bits

---------  

leetcode에 reverse bits 알고리즘 문제 풀이

결과값 0초기화 하고  
입력값 n과 1을 &연산 해서 1인 값 대해 결과값에 1을 더해준다.  
1을 n값과 &연산 하는 이유는 마지막값이 1인지 여부를 판별하여 결과값에 넣기 위한 과정이다.
그리고 loop에서 result는 왼쪽으로 쉬프트, n은 오른쪽 쉬프트 하는것은
n값을 뒤집기 위한 과정이다.

```
이진수 & 연산 

  101 
& 001 
------
  001

값이 1일때 1
```

```
//초기값
n = 13
n = 00000000000000000000000000001101
result = 00000000000000000000000000000000

//1회

result <<=1; 

//result 왼쪽으로 쉬프트
00000000000000000000000000000000 -> 00000000000000000000000000000000

//n & 1
00000000000000000000000000001101 &
00000000000000000000000000000001 = 00000000000000000000000000000001

result = 00000000000000000000000000000000 + 1 = 00000000000000000000000000000001

//n >>= 1;
00000000000000000000000000001101 = 00000000000000000000000000000110
```

```
2회
//result 왼쪽 쉬프트
00000000000000000000000000000001 = 00000000000000000000000000000010

//n & 1
00000000000000000000000000000110 &
00000000000000000000000000000001 = 00000000000000000000000000000000

값이 0이니 result값에 더하지않는다

// n >>= 1
00000000000000000000000000000110 = 00000000000000000000000000000011
```

```
3회
//result 왼쪽으로 쉬프트
00000000000000000000000000000010 -> 00000000000000000000000000000100

//n & 1
00000000000000000000000000000011 &
00000000000000000000000000000001 = 00000000000000000000000000000001

result = 00000000000000000000000000000100 + 1 = 00000000000000000000000000000101

//n >>= 1;
00000000000000000000000000000011 = 00000000000000000000000000000001

```
```
4회
//result 왼쪽으로 쉬프트
00000000000000000000000000000101 -> 00000000000000000000000000001010

//n & 1
00000000000000000000000000000001 &
00000000000000000000000000000001 = 00000000000000000000000000000001

result = 00000000000000000000000000001010 + 1 = 00000000000000000000000000001011

//n >>= 1;
00000000000000000000000000000001 = 00000000000000000000000000000000

....

//최종  
result = 00000000000000000000000000001011 = 10110000000000000000000000000000

```

나머지 회차는 n값이 0이기때문에 result값만 쉬프트 되면서 n값이 뒤집어진다.


 ## 제출 코드 
```
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        if (n == 0) return 0;

        int result = 0;
        for (int i = 0; i < 32; i++) {
            result <<= 1;
            if ((n & 1) == 1) result++;
            n >>= 1;
        }
        return result;
    }
}
```


## 참조 링크
[참조](https://leetcode.com/problems/reverse-bits/discuss/54738/Sharing-my-2ms-Java-Solution-with-Explanation)